import spacy
import re
from typing import Dict, List, Optional, Tuple
from textblob import TextBlob
from datetime import datetime
import json

class NLPService:
    """ServiÃ§o de Processamento de Linguagem Natural para o agente de vendas"""
    
    def __init__(self):
        # Carregar modelo do spaCy para portuguÃªs
        try:
            self.nlp = spacy.load("pt_core_news_sm")
        except OSError:
            print("Modelo pt_core_news_sm nÃ£o encontrado. Usando modelo em branco.")
            self.nlp = spacy.blank("pt")
        
        # Definir intenÃ§Ãµes e suas palavras-chave
        self.intent_patterns = {
            'greeting': [
                'olÃ¡', 'oi', 'bom dia', 'boa tarde', 'boa noite', 'e aÃ­', 'tudo bem',
                'como vai', 'prazer', 'hello', 'hi'
            ],
            'product_inquiry': [
                'produto', 'serviÃ§o', 'oferta', 'venda', 'comprar', 'preÃ§o', 'valor',
                'custo', 'quanto custa', 'informaÃ§Ã£o', 'detalhes', 'especificaÃ§Ã£o',
                'catÃ¡logo', 'disponÃ­vel', 'estoque'
            ],
            'demo_request': [
                'demonstraÃ§Ã£o', 'demo', 'teste', 'experimentar', 'ver funcionando',
                'apresentaÃ§Ã£o', 'mostrar', 'exemplo', 'trial', 'versÃ£o de teste'
            ],
            'pricing_inquiry': [
                'preÃ§o', 'valor', 'custo', 'quanto', 'orÃ§amento', 'cotaÃ§Ã£o',
                'investimento', 'plano', 'pacote', 'tabela de preÃ§os'
            ],
            'support_request': [
                'ajuda', 'suporte', 'problema', 'dÃºvida', 'dificuldade', 'erro',
                'nÃ£o funciona', 'bug', 'assistÃªncia', 'socorro'
            ],
            'complaint': [
                'reclamaÃ§Ã£o', 'problema', 'insatisfeito', 'ruim', 'pÃ©ssimo',
                'nÃ£o gostei', 'decepcionado', 'cancelar', 'reembolso'
            ],
            'compliment': [
                'parabÃ©ns', 'excelente', 'Ã³timo', 'muito bom', 'perfeito',
                'adorei', 'gostei', 'satisfeito', 'recomendo'
            ],
            'goodbye': [
                'tchau', 'atÃ© logo', 'atÃ© mais', 'bye', 'adeus', 'falou',
                'atÃ© a prÃ³xima', 'obrigado', 'valeu'
            ],
            'contact_info': [
                'contato', 'telefone', 'email', 'endereÃ§o', 'localizaÃ§Ã£o',
                'onde fica', 'como falar', 'whatsapp'
            ],
            'availability': [
                'disponÃ­vel', 'horÃ¡rio', 'quando', 'prazo', 'entrega',
                'funcionamento', 'aberto', 'fechado'
            ]
        }
        
        # Entidades importantes para vendas
        self.entity_patterns = {
            'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            'phone': r'(?:\+55\s?)?(?:\(?[1-9]{2}\)?\s?)?(?:9\s?)?[0-9]{4}[-\s]?[0-9]{4}',
            'money': r'R\$\s?[\d.,]+|[\d.,]+\s?reais?',
            'company': r'\b[A-Z][a-zA-Z\s]+(?:Ltda|S\.A\.|EIRELI|ME)\b',
            'name': r'\b[A-Z][a-z]+(?:\s[A-Z][a-z]+)+\b'
        }
    
    def analyze_message(self, message: str) -> Dict:
        """Analisa uma mensagem e retorna intenÃ§Ã£o, entidades e sentimento"""
        
        # Limpar e normalizar texto
        cleaned_message = self._clean_text(message)
        
        # Processar com spaCy
        doc = self.nlp(cleaned_message)
        
        # Detectar intenÃ§Ã£o
        intent = self._detect_intent(cleaned_message)
        
        # Extrair entidades
        entities = self._extract_entities(message, doc)
        
        # Analisar sentimento
        sentiment = self._analyze_sentiment(cleaned_message)
        
        # Calcular confianÃ§a
        confidence = self._calculate_confidence(intent, entities, sentiment)
        
        return {
            'intent': intent,
            'entities': entities,
            'sentiment': sentiment,
            'confidence': confidence,
            'processed_text': cleaned_message,
            'tokens': [token.text for token in doc],
            'pos_tags': [(token.text, token.pos_) for token in doc]
        }
    
    def _clean_text(self, text: str) -> str:
        """Limpa e normaliza o texto"""
        # Converter para minÃºsculas
        text = text.lower()
        
        # Remover caracteres especiais excessivos
        text = re.sub(r'[!]{2,}', '!', text)
        text = re.sub(r'[?]{2,}', '?', text)
        text = re.sub(r'[.]{2,}', '...', text)
        
        # Remover espaÃ§os extras
        text = re.sub(r'\s+', ' ', text).strip()
        
        return text
    
    def _detect_intent(self, text: str) -> str:
        """Detecta a intenÃ§Ã£o da mensagem"""
        intent_scores = {}
        
        for intent, keywords in self.intent_patterns.items():
            score = 0
            for keyword in keywords:
                if keyword in text:
                    # Dar mais peso para palavras exatas
                    if f' {keyword} ' in f' {text} ':
                        score += 2
                    else:
                        score += 1
            
            if score > 0:
                intent_scores[intent] = score
        
        if intent_scores:
            # Retornar intenÃ§Ã£o com maior score
            return max(intent_scores, key=intent_scores.get)
        
        return 'general'
    
    def _extract_entities(self, text: str, doc) -> Dict:
        """Extrai entidades do texto"""
        entities = {}
        
        # Entidades do spaCy
        spacy_entities = {}
        for ent in doc.ents:
            if ent.label_ not in spacy_entities:
                spacy_entities[ent.label_] = []
            spacy_entities[ent.label_].append(ent.text)
        
        entities['spacy'] = spacy_entities
        
        # Entidades customizadas com regex
        custom_entities = {}
        for entity_type, pattern in self.entity_patterns.items():
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                custom_entities[entity_type] = matches
        
        entities['custom'] = custom_entities
        
        return entities
    
    def _analyze_sentiment(self, text: str) -> Dict:
        """Analisa o sentimento do texto"""
        try:
            # Usar TextBlob para anÃ¡lise de sentimento
            blob = TextBlob(text)
            polarity = blob.sentiment.polarity  # -1 a 1
            subjectivity = blob.sentiment.subjectivity  # 0 a 1
            
            # Classificar sentimento
            if polarity > 0.1:
                sentiment_label = 'positive'
            elif polarity < -0.1:
                sentiment_label = 'negative'
            else:
                sentiment_label = 'neutral'
            
            return {
                'polarity': polarity,
                'subjectivity': subjectivity,
                'label': sentiment_label
            }
        except Exception as e:
            return {
                'polarity': 0.0,
                'subjectivity': 0.0,
                'label': 'neutral',
                'error': str(e)
            }
    
    def _calculate_confidence(self, intent: str, entities: Dict, sentiment: Dict) -> float:
        """Calcula a confianÃ§a da anÃ¡lise"""
        confidence = 0.5  # Base
        
        # Aumentar confianÃ§a se intenÃ§Ã£o foi detectada
        if intent != 'general':
            confidence += 0.2
        
        # Aumentar confianÃ§a se entidades foram encontradas
        if entities.get('custom') or entities.get('spacy'):
            confidence += 0.2
        
        # Aumentar confianÃ§a se sentimento Ã© claro
        if abs(sentiment.get('polarity', 0)) > 0.3:
            confidence += 0.1
        
        return min(confidence, 1.0)
    
    def generate_response(self, intent: str, entities: Dict, sentiment: Dict, 
                         lead_name: str = None, context: Dict = None) -> str:
        """Gera uma resposta humanizada baseada na anÃ¡lise"""
        
        # Templates de resposta por intenÃ§Ã£o
        response_templates = {
            'greeting': [
                f"OlÃ¡{f' {lead_name}' if lead_name else ''}! ğŸ˜Š Como posso ajudÃ¡-lo hoje?",
                f"Oi{f' {lead_name}' if lead_name else ''}! Que bom falar com vocÃª! Em que posso ser Ãºtil?",
                f"Bom dia{f' {lead_name}' if lead_name else ''}! Estou aqui para ajudar. O que vocÃª gostaria de saber?"
            ],
            'product_inquiry': [
                "Fico feliz em saber do seu interesse! Temos soluÃ§Ãµes incrÃ­veis que podem atender suas necessidades. Que tipo de produto ou serviÃ§o vocÃª estÃ¡ procurando?",
                "Que Ã³timo! Adoraria apresentar nossos produtos para vocÃª. Pode me contar um pouco mais sobre o que vocÃª precisa?",
                "Perfeito! Temos vÃ¡rias opÃ§Ãµes que podem ser ideais para vocÃª. Qual Ã© o seu principal objetivo ou necessidade?"
            ],
            'demo_request': [
                "Claro! Seria um prazer mostrar como nossa soluÃ§Ã£o funciona. Quando seria um bom horÃ¡rio para vocÃª?",
                "Excelente ideia! Uma demonstraÃ§Ã£o Ã© a melhor forma de conhecer nosso produto. VocÃª tem alguma preferÃªncia de horÃ¡rio?",
                "Perfeito! Vou agendar uma demo personalizada para vocÃª. Qual seria o melhor dia e horÃ¡rio?"
            ],
            'pricing_inquiry': [
                "Entendo sua curiosidade sobre os valores! Temos opÃ§Ãµes flexÃ­veis que se adaptam a diferentes necessidades. Posso preparar uma proposta personalizada para vocÃª?",
                "Ã“tima pergunta! Nossos preÃ§os variam conforme o pacote e necessidades especÃ­ficas. Que tal conversarmos sobre suas necessidades para eu apresentar a melhor opÃ§Ã£o?",
                "Com certeza! Para dar o melhor preÃ§o, preciso entender melhor suas necessidades. Pode me contar um pouco sobre seu projeto?"
            ],
            'support_request': [
                "Claro, estou aqui para ajudar! Pode me explicar qual dificuldade vocÃª estÃ¡ enfrentando?",
                "Sem problemas! Vamos resolver isso juntos. Me conta mais detalhes sobre o que estÃ¡ acontecendo?",
                "Entendo sua situaÃ§Ã£o. Estou aqui para dar todo o suporte necessÃ¡rio. Qual Ã© exatamente o problema?"
            ],
            'complaint': [
                "Lamento muito que vocÃª tenha tido essa experiÃªncia. Sua satisfaÃ§Ã£o Ã© muito importante para nÃ³s. Pode me contar o que aconteceu para eu poder ajudar?",
                "PeÃ§o desculpas pelo inconveniente. Vamos resolver isso da melhor forma possÃ­vel. Me explica a situaÃ§Ã£o para eu entender melhor?",
                "Sinto muito por isso. Sua opiniÃ£o Ã© muito valiosa e queremos melhorar. Pode me dar mais detalhes sobre o problema?"
            ],
            'compliment': [
                "Muito obrigado pelo feedback positivo! Fico muito feliz em saber que vocÃª estÃ¡ satisfeito. Ã‰ isso que nos motiva a continuar melhorando!",
                "Que alegria receber esse retorno! Obrigado por compartilhar sua experiÃªncia positiva conosco!",
                "Fico emocionado com seu comentÃ¡rio! Ã‰ muito gratificante saber que conseguimos atender suas expectativas!"
            ],
            'goodbye': [
                f"Foi um prazer conversar com vocÃª{f' {lead_name}' if lead_name else ''}! Qualquer coisa, estarei aqui. Tenha um Ã³timo dia! ğŸ˜Š",
                f"Obrigado pela conversa{f' {lead_name}' if lead_name else ''}! AtÃ© logo e conte comigo sempre que precisar!",
                f"Tchau{f' {lead_name}' if lead_name else ''}! Foi Ã³timo falar com vocÃª. Estarei sempre disponÃ­vel para ajudar!"
            ],
            'contact_info': [
                "Claro! VocÃª pode entrar em contato conosco pelo WhatsApp, email ou telefone. Qual forma de contato vocÃª prefere?",
                "Sem problemas! Temos vÃ¡rios canais de atendimento disponÃ­veis. Como vocÃª gostaria de manter contato?",
                "Perfeito! Estamos sempre disponÃ­veis para conversar. Qual Ã© a melhor forma de contato para vocÃª?"
            ],
            'availability': [
                "Estamos disponÃ­veis de segunda a sexta, das 8h Ã s 18h. Mas pelo WhatsApp, sempre que possÃ­vel, respondemos fora do horÃ¡rio tambÃ©m!",
                "Nosso atendimento funciona de segunda a sexta, das 8h Ã s 18h. Posso ajudar vocÃª agora mesmo!",
                "Estamos aqui para vocÃª! HorÃ¡rio de atendimento: segunda a sexta, 8h Ã s 18h. O que vocÃª precisa?"
            ],
            'general': [
                "Entendi! Como posso ajudar vocÃª da melhor forma?",
                "Interessante! Me conta mais sobre isso para eu poder ajudar melhor.",
                "Certo! Estou aqui para ajudar. O que vocÃª gostaria de saber?"
            ]
        }
        
        # Selecionar template baseado na intenÃ§Ã£o
        templates = response_templates.get(intent, response_templates['general'])
        
        # Escolher template baseado no sentimento
        if sentiment.get('label') == 'negative' and intent not in ['complaint', 'support_request']:
            # Para sentimentos negativos, ser mais empÃ¡tico
            empathetic_responses = [
                "Entendo sua preocupaÃ§Ã£o. Estou aqui para ajudar da melhor forma possÃ­vel.",
                "Percebo que vocÃª pode estar com alguma dÃºvida ou dificuldade. Vamos resolver isso juntos!",
                "Compreendo. Deixe-me ajudar vocÃª a esclarecer tudo."
            ]
            return empathetic_responses[0]
        
        # Retornar primeira opÃ§Ã£o do template (pode ser randomizado no futuro)
        return templates[0]
    
    def should_escalate(self, intent: str, sentiment: Dict, confidence: float, 
                       conversation_history: List = None) -> Dict:
        """Determina se a conversa deve ser escalonada para um humano"""
        
        escalation_reasons = []
        should_escalate = False
        
        # Escalar se confianÃ§a Ã© muito baixa
        if confidence < 0.3:
            escalation_reasons.append("Baixa confianÃ§a na anÃ¡lise da mensagem")
            should_escalate = True
        
        # Escalar para reclamaÃ§Ãµes sÃ©rias
        if intent == 'complaint' and sentiment.get('polarity', 0) < -0.5:
            escalation_reasons.append("ReclamaÃ§Ã£o com sentimento muito negativo")
            should_escalate = True
        
        # Escalar para pedidos de suporte complexos
        if intent == 'support_request' and confidence < 0.5:
            escalation_reasons.append("Pedido de suporte complexo")
            should_escalate = True
        
        # Escalar se muitas mensagens sem resoluÃ§Ã£o
        if conversation_history and len(conversation_history) > 5:
            recent_intents = [msg.get('intent') for msg in conversation_history[-5:]]
            if recent_intents.count('general') >= 3:
                escalation_reasons.append("MÃºltiplas mensagens sem intenÃ§Ã£o clara")
                should_escalate = True
        
        return {
            'should_escalate': should_escalate,
            'reasons': escalation_reasons,
            'priority': 'high' if sentiment.get('polarity', 0) < -0.5 else 'medium'
        }


# InstÃ¢ncia global do serviÃ§o
nlp_service = NLPService()

